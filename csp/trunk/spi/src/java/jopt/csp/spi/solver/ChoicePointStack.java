package jopt.csp.spi.solver;

import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;

/**
 * The <code>ChoicePointStack</code> object represents a stack that contains the state of a CSP problem 
 * at decision points of a searching algorithm.  The data contained within the constraint store 
 * and domains for all variables can be pushed onto <code>ChoicePointStack</code> by calling
 * the {@link #push} method.  The data for constraint store and all domains can later be rolled
 * back by calling the {@link #pop} method on the stack.
 * <p>
 * The <code>ChoicePointStack</code> provides this functionality through the creation of
 * {@link ChoicePointDataMap} objects. A <code>ChoicePointDataMap</code> is a specialized map object
 * that listens to events generated by the <code>ChoicePointStack</code>.  When the stack is pushed,
 * all values in the <code>ChoicePointDataMap</code> are removed. When the stack is popped, the
 * values in the <code>ChoicePointDataMap</code> return to the map. Domains and constraint stores
 * record changes in the map objects that can be undone when a stack is popped.
 * <p>
 * Searching algorithms call the <code>push</code> method of the <code>ChoicePointStack</code>
 * object before choosing a variable to assign a value. If the value assigned to a variable
 * generates a {@link jopt.csp.variable.PropagationFailureException}, the search algorithm 
 * can pop the stack to roll back changes to the variables in order to try another value or 
 * variable.  In this way, search algorithms are provided a tool that allows all valid 
 * variable / value combinations to be determined.
 * <p>
 * This class is not thread safe.
 * 
 * @author Nick Coleman
 * @version %I%
 */
public class ChoicePointStack implements ChoicePointEntryCloseListener {
    private int nextEntryID;
    private Map dataEntryOrder;
    private int maxKey;
    private int depth;
    
    /**
     * Creates a new <code>ChoicePointStack</code> object.
     */
    public ChoicePointStack() {
        this.dataEntryOrder = Collections.synchronizedMap(new HashMap());
    }
    
//    /**
//     * Creates a new <code>ChoicePointDataMap</code> associated with this stack. 
//     * The map will respond to push and pop actions on this stack with a default
//     * order to pop of 5.
//     * 
//     * @return <code>ChoicePointDataMap</code> associated with this stack
//     */
//    public ChoicePointDataMap newDataMap() {
//        return newDataMap(5);
//    }
//    
//    /**
//     * Creates a new <code>ChoicePointDataMap</code> associated with this stack. 
//     * The map will respond to push and pop actions on this stack. Popping will
//     * occur in the order specified.
//     * 
//     * @param order     Order value indicating at what stage map should be popped
//     * @return <code>ChoicePointDataMap</code> associated with this stack
//     */
//    public ChoicePointDataMap newDataMap(int order) {
//        this.maxKey = Math.max(maxKey, order);
//        
//        Integer entryID = new Integer(nextEntryID++);
//        ChoicePointDataMap map = new ChoicePointDataMap(this, entryID);
//        
//        // retrieve map to store listener
//        Integer key = new Integer(order);
//        PooledMap dataMapHash = (PooledMap) dataEntryOrder.get(key);
//        if (dataMapHash==null) {
//            dataMapHash = PooledMap.borrow();
//            dataEntryOrder.put(key, dataMapHash);
//        }
//        
//        dataMapHash.put(entryID, map);
//        return map;
//    }
    
    /**
     * Creates a new <code>ChoicePointNumArraySet</code> associated with this stack. 
     * The map will respond to push and pop actions on this stack with a default
     * order to pop of 5.
     * 
     * 
     * @param listener  Object interested in listening for rollback events on map
     * @return <code>ChoicePointNumArraySet</code> associated with this stack
     */
    public ChoicePointNumArraySet newNumStackSet(ChoicePointEntryListener listener) {
    	return newNumStackSet(listener, 5);
    }
    
    /**
     * Creates a new <code>ChoicePointNumArraySet</code> associated with this stack. 
     * The list will respond to push and pop actions on this stack. Popping will
     * occur in the order specified.
     * 
     * @param listener  Object interested in listening for rollback events on stacks
     * @param order     Order value indicating at what stage list should be popped
     * @return <code>ChoicePointNumArraySet</code> associated with this stack
     */
    public ChoicePointNumArraySet newNumStackSet(ChoicePointEntryListener listener, int order) {
        this.maxKey = Math.max(maxKey, order);
        
        Integer entryID = new Integer(nextEntryID++);
        ChoicePointNumArraySet set = new ChoicePointNumArraySet(this, entryID);
        set.setListener(listener);
        
        // retrieve map to store listener
        Integer key = new Integer(order);
        Map dataEntryHash = (Map) dataEntryOrder.get(key);
        if (dataEntryHash==null) {
            dataEntryHash = Collections.synchronizedMap(new HashMap());
            dataEntryOrder.put(key, dataEntryHash);
        }
        
        dataEntryHash.put(entryID, set);
        return set;
    }
    
    /**
     * Creates a new <code>ChoicePointDataMap</code> associated with this stack and
     * attaches a listener to the map. 
     * The map will respond to push and pop actions on this stack and will notify
     * the listener object that a pop action has been initiated allowing data
     * stored in the map to be acted upon before it is discarded.
     * 
     * @param listener Object interested in listening for rollback events on map
     * @return <code>ChoicePointDataMap</code> associated with this stack
     * @see ChoicePointDataMap 
     */
    public ChoicePointDataMap newDataMap(ChoicePointEntryListener listener) {
        return newDataMap(listener, 5);
    }
    
    /**
     * Creates a new <code>ChoicePointDataMap</code> associated with this stack and
     * attaches a listener to the map. 
     * The map will respond to push and pop actions on this stack and will notify
     * the listener object that a pop action has been initiated allowing data
     * stored in the map to be acted upon before it is discarded.
     * 
     * @param listener Object interested in listening for rollback events on map
     * @param order     Order value indicating at what stage map should be popped
     * @return <code>ChoicePointDataMap</code> associated with this stack
     * @see ChoicePointDataMap 
     */
    public ChoicePointDataMap newDataMap(ChoicePointEntryListener listener, int order) {
    	this.maxKey = Math.max(maxKey, order);
    	
    	Integer entryID = new Integer(nextEntryID++);
    	ChoicePointDataMap map = new ChoicePointDataMap(this, entryID);
    	
    	// retrieve map to store listener
    	Integer key = new Integer(order);
    	Map dataMapHash = (Map) dataEntryOrder.get(key);
    	if (dataMapHash==null) {
    		dataMapHash = Collections.synchronizedMap(new HashMap());
    		dataEntryOrder.put(key, dataMapHash);
    	}
    	
    	dataMapHash.put(entryID, map);
        map.setListener(listener);
        return map;
    }
    
    /**
     * Closes a <code>ChoicePointEntry</code> associated with this stack. 
     * The map will be disconnected from the stack an no more events will be
     * associated with it.
     * 
     * @param entryID   ID of the entry belonging to this stack that should be closed
     */
    public void entryClosedEvent(Integer entryID) {
        // remove from all hashmaps
        Iterator keyIter = dataEntryOrder.keySet().iterator();
        while (keyIter.hasNext()) {
        	Map dataEntryHash = (Map) dataEntryOrder.get(keyIter.next());
            
            // map should only be in one hash
            if (dataEntryHash!=null && dataEntryHash.remove(entryID)!=null)
                break;
        }
    }
    
    /**
     * Pushes current state of CSP problem onto stack. Called by searching algorithms
     * to record the current state of the constraint store and all domains for a problem
     * before continuing altering a variable to locate a solution. This action can be undone
     * by calling the {@link #pop} method.
     */
    public void push() {
        // remove from all hashmaps
        Iterator keyIter = dataEntryOrder.keySet().iterator();
        while (keyIter.hasNext()) {
            Object key = keyIter.next();
            Map dataEntryHash = (Map) dataEntryOrder.get(key);
            
            // reset data in entry after push
            Iterator entryIter = dataEntryHash.keySet().iterator();
            while (entryIter.hasNext()) {
                // restore changes to choicepoint entry
                Integer entryID = (Integer) entryIter.next();
                ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                entry.push();
            }
        }
        
        depth++;
    }

    /**
     * Pushes current state of CSP problem onto stack. Called by searching algorithms
     * to record the current state of the constraint store and all domains for a problem
     * before continuing altering a variable to locate a solution. This action can be undone
     * by calling the {@link #pop} method.
     * 
     * @param delta Delta of changes to push back onto stack
     */
    public void pushDelta(Object delta) {
        Map deltaOrder = (Map) delta;
        
        // remove from all hashmaps
        Iterator keyIter = dataEntryOrder.keySet().iterator();
        while (keyIter.hasNext()) {
            Object key = keyIter.next();
            Map dataEntryHash = (Map) dataEntryOrder.get(key);
            Map deltaMap = (deltaOrder) != null ? (Map) deltaOrder.get(key) : null;
            
            // push empty map of data onto map's stack
            if (deltaMap==null) {
                Iterator entryIter = dataEntryHash.keySet().iterator();
                while (entryIter.hasNext()) {
                    Integer entryID = (Integer) entryIter.next();
                    ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                    entry.push();
                }
            }
            
            // restore delta of changes that was pushed onto stack
            else {
                Iterator entryIter = dataEntryHash.keySet().iterator();
                while (entryIter.hasNext()) {
                    // restore changes to choicepoint entry
                	Integer entryID = (Integer) entryIter.next();
                    ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                    entry.pushDelta(deltaMap.get(entryID));
                }
            }
        }
        
        depth++;
    }
    
    /**
     * <p>
     * Pops current state of the CSP problem off the stack. Called by searching algorithms
     * to roll back changes to a constraint store and all domains for a problem allowing
     * a problem to return to a previous state before continuing down a different path. The
     * {@link #push} method should be called before calling this method.
     * </p>
     * <p>
     * This method is more efficient to the <code>popDelta</code> method and is encouraged
     * for use if delta information is not necessary
     * </p>
     */
    public void pop() {
        // remove from all entries
        for (int i=0; i<=maxKey; i++) {
            Object key = new Integer(i);
            Map dataEntryHash = (Map) dataEntryOrder.get(key);
            
            // ensure data exists for key
            if (dataEntryHash!=null) {
                
                // pop data in all entries
                LinkedList keys = new LinkedList(dataEntryHash.keySet());
                Iterator entryIter = keys.iterator();
                while (entryIter.hasNext()) {
                    Integer entryID = (Integer) entryIter.next();
                    ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                    entry.pop();
                }
            }
        }
        
        depth--;
    }
    
    /**
     * Pops current state of the CSP problem off the stack. Called by searching algorithms
     * to roll back changes to a constraint store and all domains for a problem allowing
     * a problem to return to a previous state before continuing down a different path. The
     * {@link #push} method should be called before calling this method.
     * 
     * @return Delta of changes that has occurred on stack and can be restored by calling push
     */
    public Object popDelta() {
        Map deltaMap = Collections.synchronizedMap(new HashMap());
        
        // remove from all entries
        for (int i=0; i<=maxKey; i++) {
            Object key = new Integer(i);
            Map dataEntryHash = (Map) dataEntryOrder.get(key);
            
            // ensure data exists for key
            if (dataEntryHash!=null) {
            	Map delta = Collections.synchronizedMap(new HashMap());
                deltaMap.put(key, delta);
            
                // store changes of each entry in delta
                LinkedList keys = new LinkedList(dataEntryHash.keySet());
                Iterator entryIter = keys.iterator();
                while (entryIter.hasNext()) {
                    Integer entryID = (Integer) entryIter.next();
                    ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                    
                    if (entry!=null)
                    	delta.put(entryID, entry.popDelta());
                }
            }
        }
        
        depth--;
        
        return deltaMap;
    }
    
    /**
     * Resets all data in the choicepoint stack to original values
     */
    public void reset() {
        // pop all data in all depths
        while (depth>=0)
            pop();
        
        // reset depth
        depth = 0;
    }

    public String toString() {
        StringBuffer buf = new StringBuffer("<<<<<<< Choice Point Stack >>>>>>>\n");
        buf.append("depth: ");
        buf.append(Integer.toString(depth));
        buf.append('\n');
        buf.append('\n');
        
        // loop through all priority levels
        for (int i=0; i<=maxKey; i++) {
            Object key = new Integer(i);
            Map dataEntryHash = (Map) dataEntryOrder.get(key);
            
            // ensure data exists for key
            if (dataEntryHash!=null) {
                buf.append("===== Priority ");
                buf.append(key);
                buf.append(" =====");
                buf.append('\n');
                
                // loop over all entries
                Iterator entryIter = dataEntryHash.keySet().iterator();
                while (entryIter.hasNext()) {
                    Integer entryID = (Integer) entryIter.next();
                    ChoicePointEntry entry = (ChoicePointEntry) dataEntryHash.get(entryID);
                    buf.append(entry);
                    buf.append('\n');
                }
            }
        }
        
        return buf.toString();
    }
}